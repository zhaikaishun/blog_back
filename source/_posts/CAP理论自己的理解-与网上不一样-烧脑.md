---
title: CAP理论自己的理解与网上不一样感觉烧脑
date: 2018-11-14 21:25:21
tags: [分布式,架构]
categories: [java]
author: kaishun
id: 225
permalink: cap
---

## Consistency  
- 通过某个节点的写操作结果对后面通过其它节点的读操作可见
- 如果更新数据后，并发访问情况下可立即感知该更新，称为强一致性
- 如果允许之后部分或者全部感知不到该更新，称为弱一致性
- 若在之后的一段时间（通常该时间不固定）后，一定可以感知该更新，称为最终一致性


## Availability  
- 任何一个没有发生故障的节点必须在有限的时间内返回合理的结果

 
## Partition tolerance  
- 部分节点宕机或者无法与其它节点通信时，各分区间还可保持分布式系统的功能


## CAP理论  
分布式系统中，一致性、可用性、分区容忍性最多只可同时满足两个 


P一般是要满足的，如果牺牲P，相当于就只有一台节点,显然我们是想研究分布式的，所以我们默认P是满足的，一般我们只考虑CP或者AP。  
我们来讨论如下几点  
如果已经满足CP， 我们来看看是否会满足A  
## 如图一：读的情况：      
当满足CP时，如果客户端给client想get(key1)。客户端向node002发送一个请求，这时候node02得到自己的值为value1，
这时候，因为需要满足C，node002并不知道这个值是不是最新的，需要去node01也去get一下，查看是否node02是否也是最新的，然后返回最新的给client。  
因为集群能满足p，所以如果node01和node02的网络是允许断开的，如果断开了。这时候去get可能会长时间get不到，这时候有两种可能，一种是长时间等待不返回，
一种是一段时间后返回一个可能不合理的结果，这时候，就和我们的A：任何一个没有发生故障的节点必须在有限的时间内返回合理的结果相矛盾。  
## 如图二：写的情况：  
当满足CP时，如果客户端update(key1)为value2， 此时向node02发送一个更新操作，node02也需要向node01也发送一个更新操作，因为需要满足P，需要两个都更新成功后，
才能返回success，否则node01和node02需要回滚，因为集群能满足P，那么当node01和node02之间网络断开时，node02向node01发送的更新操作得不到响应或者发送不过去，
这时候node02可能就一直等待，或者某个时间内返回一个error，同时进行回滚操作。这和我们得A：任何一个没有发生故障的节点必须在有限的时间内返回合理的结果相矛盾。  

client向N2更新某个数据的时候，首先N2自己会上一把锁，然后会去看能不能和N1通信，如果不能通信，那么这个更新就一直等待吧，N2的锁还一直保持着，能通信的时候，
就将N1节点上的这个数据给上锁，然后N1完成更新后，释放N1的锁，把更新的状态告诉N2，如果更新失败，N2就不进行更新操作，释放锁，返回一个false。 如果N1释放锁后，想把更新的
状态告诉N2，但是如果此时处于无法通信的状态，N2会一直等待N1的反馈，将会一直锁定着N2（或者将返回false，并且将N2节点的这个值不更新，但是版本号要向上升级，然后再返回false，
否则N1的版本号就比N2的版本号高了，下次读取的时候，数据就改变了）
client向N1读取某个更新数据的时候，需要得到N1和N2节点中最新版本的那份数据，如果其中有被写锁锁住的话，就等待着，等写锁释放后再读取.有可能会一直等待，
也有可能等待一段时间后返回一个不合理的值
## 分析1
**我现在的把上面分为两种，一种是一致性读，一种是一致性写。**  
所谓的一致性，个人认为首先对于一致性读（每个节点都要读取一遍，有时候判断锁），这个是必须得满足的，不然不可能出现每次读取都是同样的数据的情况。  
或许有的人会说，那一致性写能满足的话，各个节点之间的数据是一致的，那我读任何一个阶段不都一样的吗？ 我否认这个观点，举个例子：  
client向N2更新，N2让N1更新，N1更新后，释放自己的锁，将成功的状态反馈给N2，N2需要等待N1反馈后自己再更新并且释放锁，如果说N2和N1此时的网络断开了，N2会一直等待，
锁一直不会释放。此时如果一个client向N1请求后，直接返回了最新值，那可能和到时候的写失败就有矛盾了，因为有了脏数据了。所以个人认为，一致性读是必要要有的。  
**一致性写，我觉得是可以不需要的**，但是为什么这里强调一下使用一致性写呢？ 我猜测是为了宕机准备的，为了保证每一台机器都一样，如果有宕机，其他几台机器仍然可以使用，仍然有
最新的数据

